#!/usr/bin/env bash
#===============================================================================
##     __    __          __
##    / /_  / /___ _____/ /__
##   / __ \/ / __ `/ __  / _ \
##  / /_/ / / /_/ / /_/ /  __/
## /_.___/_/\__,_/\__,_/\___/
##
#-------------------------------------------------------------------------------
#$ name:bladex
#$ author:qodeninja
#$ autobuild: 00004
#$ date:
#-------------------------------------------------------------------------------q
#=====================================code!=====================================

  args=("${@}");readonly T=0 F=1;


  out=
  err=

  INPUT=
  OUTPUT=

	_buf=()
  _git=()

  range=20;

#-------------------------------------------------------------------------------
# TERM
#-------------------------------------------------------------------------------

	#TERM ESCAPE
	red=$(tput setaf 9);
	green=$(tput setaf 2);
	blue=$(tput setaf 12);
	yellow=$(tput setaf 11);
	orange=$(tput setaf 214);
	grey=$(tput setaf 244);
	purple=$(tput setaf 213);
	pink=$(tput setaf 169);
	white=$(tput setaf 15);
	wz=$(tput setaf 248);
	x=$(tput sgr0);
	eol=$(tput el);

	#GLYPHS ESCAPE
	idelta='\xE2\x96\xB3';
	ipass='\xE2\x9C\x93';
	ifail='\xE2\x9C\x97';
	ilambda='\xCE\xBB';
	idiamond='\xE1\x9B\x9C';
	idots='\xE2\x80\xA6';
	istar='\xE2\x98\x85';
	ilock='\xEF\xA1\x80';
	iflecha='\xC2\xBB';
	iflecha2='\xC2\xAB';

	#SELF CLIP
	logo=$(sed -n '3,8 p' $BASH_SOURCE)

	#EXPLICIT
	tab=$'\t';
	nl=$'\n';
	rl=$'\r';
	sp=$'  ';

	space='\x20';

	# KEY ESCAPES ( sed -n l )
	ESCAPE_SEQ=$'\033'
	UP=$'A'
	DOWN=$'B'
	LEFT=$'C'
	RIGHT=$'D'
	SPACER=$'\x20'
	RETKEY=$'\x0a'
	PAGEUP=$'[5~' #^[[5~
	PAGEDOWN=$'[6~' #^[[6~

#-------------------------------------------------------------------------------
# EARLY-OPTIONS
#-------------------------------------------------------------------------------

	opt_log_color=0;

	[[ "${@}" =~ --?(y|yes)   ]]; opt_yes=$?;
	[[ "${@}" =~ --?(Q|quiet) ]]; opt_quiet=$?;

	[[ "${@}" =~ --?(d|debug)[=:]([0-9]+) ]]; opt_debug=$?;
	opt_log_level="${BASH_REMATCH[2]:-${DEBUG_LVL:-3}}";

	[[ "${@}" =~ --?(S|src)[=:]([^=:]+) ]]; opt_src=$?;
	opt_src_arg="${BASH_REMATCH[2]:-}";

#-------------------------------------------------------------------------------
# VARS
#-------------------------------------------------------------------------------

	BLADE_LOAD=$F;
	BLADE_RC="$HOME/.bladerc"
	BLADE_OUT="$HOME/blade.out";
	BLADE_ROOT_SRC=

	LOCAL_BIN="$HOME/.local/bin";

#-------------------------------------------------------------------------------
# Traps
#-------------------------------------------------------------------------------

	fullscreen(){ tput smcup; printf "\e[?25l"; return 0; }
	exitscreen(){ tput rmcup; printf "\e[?25h"; return 0; }
  handle_sigint(){ s="$?"; kill 0; exit $s;  }
  handle_sigtstp(){ kill -s SIGSTOP $$; }
  handle_input(){ [ -t 0 ] && stty -echo -icanon time 0 min 0; }
  cleanup(){ [ -t 0 ] && stty sane; }
  fin(){
    local E="$?"
    cleanup
    [ $E -eq 0 ] && printf "${green}11${ipass} ${1:-Done}.${x}\n\n" \
                 || printf "${red}${ifail} ${1:-${err:-Cancelled}}.${x}\n\n"
  }
  trap handle_sigint INT
  trap handle_sigtstp SIGTSTP
  trap handle_input CONT
  trap fin EXIT


#-------------------------------------------------------------------------------
# PRINT
#-------------------------------------------------------------------------------

	stderr(){ printf -- "${@}" 1>&2; }
	nprint(){  [ $opt_quiet -eq 1 ] && printf "%s%b%s" "${!2:-}" "${1:-}" 1>&2; } ## 2 color is deref
	nlprint(){ [ $opt_quiet -eq 1 ] && printf "%s%b%s" "${!2:-}" "${1:-}" "$nl" 1>&2; }
	print_line(){ printf -v v "%-*s" "$2" ""; echo "${v// /$1}"; }
	line="$(print_line '-' 50)";

#-------------------------------------------------------------------------------
# STDERR LOG
#-------------------------------------------------------------------------------

	log_n(){ :
		## 1 log_level
		local color txt pre lvl=${1:-1};
		if [ $lvl -le $opt_log_level ]; then
			## 2 log_color
			[ $opt_log_color -eq $T  ] && color="${!2}" || color=''
			## 3 log_preamble
			[ ! -z "$3" ] && pre="${!3}" || pre=''
			## 4 log_message
			txt="${4:-}";
			[ ! -z "$txt" ] && nlprint "$color${pre}$txt${x}";
		else
			:
		fi
	}

	log_error(){ log_n 1 "red"    "ifail"   " $1"; }
	log_pass(){  log_n 2 "green"  "ipass"   " $1"; }
	log_warn(){  log_n 2 "orange" "idelta"  "$1";  }
	log_info(){  log_n 3 "blue"   "ilambda" "$1";  }
	log_silly(){ log_n 4 "purple" "istar"   " $1"; }

#-------------------------------------------------------------------------------
# USER INPUT
#-------------------------------------------------------------------------------
	bg="${bld}${green}" br="${bld}${red}"

	confirm(){
		local src ret cont=1 auto=${2:-0} y=$opt_yes ret=1;
		nprint "${rl}${1}? > " "white2";

		[[ "$auto" = "c" ]] && { auto=0; cont=0; } #continue with enter

		[ $y -eq 0 -a $auto -eq 1 ] && nlprint "${br}auto no${x}\n" && return 1;
		[ $y -eq 0 ] && nlprint "${bg}auto yes${x}\n" && return 0;

		while read -n 1 -s INPUT; do
			[ ${#INPUT} -eq 0 -a $cont -eq 0 ] && nprint "${bg}yes${x}" && return 0 || :
			[ $? -eq 1 ] && stderr "Error occured?" && exit 1;
			if [[ $INPUT = [YyNn10tf+\-q] ]]; then
				[[ $INPUT = [Yyt1+] ]] && stderr "${bg}yes${x}" && ret=0 || :
				[[ $INPUT = [Nnf0\-] ]] && stderr "${br}no${x}" && ret=1 || :
				[[ $INPUT = [q] ]] && stderr "\n" && exit 1 || :
				break
			fi
		done
		stderr " ${nl}${x}"
		return $ret
	}


  prompt(){
    local IFS res ret next ask="$1" auto="$2" y=$opt_yes ret=1;

    [ $y -eq 0 ] && [ ! -n "$auto" ] && die "Missing default value specified for auto-yes prompt";
    [[ "$auto" = "c" ]] && { auto=""; } #continue as clear

    [ $y -eq 0 ] && nlprint "${bg}auto default:[${auto}]${x}" && echo "$auto" && return 0;
    [ -n "$auto" ] && ask="$ask ($auto)" || :

    while [[ -z "$next" ]]; do
      IFS= read -p "${x}$ask? > ${bg}" INPUT; next=1; stderr "$nl${x}";
    done
    [ -n "$auto" -a ! -n "$INPUT" ] && INPUT="$auto";
    echo "$INPUT"
  }


	prompt_path(){
		local res ret next ask="$1" sure="$2" default="$3"
		ask=$(eval echo "$ask")
		while [[ -z "$next" ]]; do
		  read -p "$ask? > ${bld}${green}" INPUT;
		  res=$(eval echo "$INPUT")
		  [ -z "$res" ] && res="$default";
		  if [ -n "$res" ]; then
		  	[ "$res" = '?' ] && { err="Cancelled"; return 1; } || :
		    if confirm "${x}${sure} [ ${blue}$res${x} ] (y/n)"; then
		    	[ -d "$res" ] && next=$T || {
		    		log_error "Couldn't find the directory ($res). Try Again. Or '?' to cancel.";
		    	};
		    fi
		  else
		    log_warn "Invalid Entry! Try Again."
		  fi
		done
		echo "$res"
	 }


  wait_job(){
    local info="$1" task="${2:-Task}" spin='-\|/' i=0 pid=$!; # Process Id of the previous running command
    tput civis
    while kill -0 $pid 2>/dev/null; do
      i=$(( (i+1) %4 ))
      printf "\r${blue}${spin:$i:1} ${info}... $x"
      sleep .1
    done
    printf "\r${green}${ipass} Done! ${task}${x}$eol$nl"
    tput cnorm
  }

	wait_noop(){
		local n l;n=0
		while test $n -lt 3; do
			#read l
			sleep 0.5
			echo -n " "
			n=$[n+1]
		done
		printf "$x"
		printf "\r$green$pass Done. $x$eol\n"
		clear
	}

#-------------------------------------------------------------------------------
# UTILS
#-------------------------------------------------------------------------------

  noop(){ err="${last_cmd:-NOOP}"; return 1; }
  command_exists(){ type "$1" &> /dev/null; }
  def(){ printf -v "$1" '%s' "$2"; }
	abs(){ printf $(realpath $1); }

	is_path(){ [ ! -z "$1" ] && [ -e "$1" ]; }
	is_true(){ [ ! -z "$1" ] && [ "$1" = "$T" ]; }

	joinby(){ local IFS="$1"; shift; echo "$*"; }
  in_array(){ local e; for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done; return 1;}

	print_array(){
		local i this arr=("${@}") len=${#arr[@]} #"${@:2}"
		if [ $len -gt 0 ]; then
			for i in ${!arr[@]}; do
				this="${arr[$i]}"
				nlprint "$i:$this"
			done
		fi
	}

	ceiling(){ echo $((($1+$2-1)/$2)); }

#-------------------------------------------------------------------------------
# BUFFER UTILS
#-------------------------------------------------------------------------------

  get_buffer(){ printf "${_buf[*]}"; }
  buffer_size(){ printf "${#_buf[@]}"; }
  print_buffer(){ for i in "${_buf[@]}" ; do echo "$i" ; done; }
  clear_buffer(){ _buf=(); }
	uniq_buffer(){ _buf=( $(printf "%s\n" "${@}" | uniq | sort ) ); }


	buffer_load_repos(){
		_buf=($(awk -F'.git' '{ sub ("^./", "", $1); print $1; }' <(for i in "${_git[@]}" ; do echo "${i//$BLADE_ROOT_SRC/}" ; done)))
	}

	cached_buffer(){
		:
	}
#-------------------------------------------------------------------------------
# RC
#-------------------------------------------------------------------------------


	file_rc_str(){
		local size
		size=${#__repo_list[@]};
		size=$((size-1))
		local str="$(cat <<-EOF
			#!/usr/bin/env bash
			BLADE_ROOT_SRC="$BLADE_ROOT_SRC"
			BLADE_JUMP="$BLADE_JUMP"
			BLADE_SIZE=$size
			if [[ "\$1" =~ "--blade-vars" ]]; then
				_buf=(${_buf[*]})
				_git=(${_git[*]})

				__group_list=(${__group_list[*]})
				__group_map=(${__group_map[*]})
				__gdir_map=(${__gdir_map[*]})
				__repo_list=(${__repo_list[*]})
				__rdir_map=(${__rdir_map[*]})
				__alias_list=(${__alias_list[*]})
				__alias_map=(${__alias_map[*]})
			fi
			BLADE_LOAD=$T
		EOF
		)";
		echo "$str"
	}

	save_rc_file(){
		#rm $BLADE_RC
		[ -n ${BLADE_RC} ] && echo "$(file_rc_str)" > ${BLADE_RC} || :;
		#__print $dline
		#cat $BLADE_RC
		#__print $dline
	}

	load_rc_file(){
		[ ! -f "$BLADE_RC" ] && err="Missing BLADE_RC file ($BLADE_RC)" && return 1;
		source $BLADE_RC --blade-vars
	}

#-------------------------------------------------------------------------------
# SCREEN
#-------------------------------------------------------------------------------

	logo_screen(){
		clear
		fullscreen
		printf "\n\n\n\n\n$blue${logo//#/ }$x\n\n\t$1"
	}


	menu_rerender(){
		local i j r buf len sel act ttl pre first last n max=0 page=1 pages=1;
		sel="$1"
		act=${2:-0};
		buf=("${_buf[@]}")
		len=${#_buf[@]}

		if [ $len -gt $range ]; then
			((pages=(len+range-1)/range))
		fi

		if [ $len -gt 0 ]; then

			((j=sel+1)) #index is offset by 1 for menu
			((page=j/(range+1)+1)) #current page calculation
			((max=range*(page-1)+(range+1))); #max elements per page with offset

			#adjust range based on selection
			if [ $j -ge $max ]; then
				((first=j-max+1))
				((last=j+range))
				n=$T;
			else
				n=$F;
				((first=max-(range+1)))
				((last=max-1))
			fi

			printf "\n\n\n$tab${__buf_msg} (sel:$j of $len) $nl" #(sel:$j of $len ($max) (range $first:$last) ${_stat[$sel]}) ($page of $pages) ($n) \n\n"

			paged_buf=("${buf[@]:$first:$last}")

			if ((pages>1)); then
				printf "$nl$tab $space $yellow($page of $pages)$x${nl}${nl}"
			fi

			for i in ${!paged_buf[@]}; do
				((j=i+1))
				((r=i+(page-1)*range))
				pre=
				this="${buf[$r]}"
				this_st="${_stat[$r]}"
				if [ $act -eq 0 ]; then
					case "$this_st" in
						"sel")  pre="$green[$ipass]$x";;
						"del")  pre="$red[$ifail]$x";;
						"none") pre="[$idiamond]";;
						*);;
					esac
				else
					[[ "$r" = "$sel" ]] && pre="$purple[$idiamond]" || pre="[$idiamond]"
				fi

				[[ "$r" = "$sel" ]] && delim="$purple$iflecha$x" || delim="$space"
				printf "$tab $delim $pre %-2d $this$x\n" "$((r+1))"
			done

		fi
	}


	selection_buffer(){

		local buf len idx tmp act go key IFS pages;

		idx=0
		act=${2:-0};go=0
		buf=("${_buf[@]}")
		len=${#buf[@]};
		[ $len -eq 0 ] && return 1;
		((len-=1))

		if [ $len -gt $range ]; then
			((pages=(len+range-1)/range))
		fi

		__buf_msg="\n\n$orange${logo//#/ }$x\n\n\t${orange}$1$x"
		fullscreen

		for i in ${buf[@]}; do
			_stat+=('none')
		done

		clear

		OLDIFS="$IFS"
		IFS=''
		cleanup

		while true; do

			menu_rerender $idx "$act";
			read -rsn 1 key

			case "$key" in
				$ESCAPE_SEQ)
					read -rsn 1 -t 1 tmp
					if  [[ "$tmp" == "[" ]]; then
						read -rsn 1 -t 1 arrow
						case "$arrow" in
							$UP)
							  [ $idx -ne 0 ] && ((idx-=1)) || :
								;;
							$DOWN)
								[ $idx -lt $len ] && ((idx+=1)) || :
								;;
							$LEFT)
								[[ ${_stat[$idx]} = 'del' ]] && _stat[$idx]='none' || _stat[$idx]='sel'
								;;
							$RIGHT)
								clear
								[[ ${_stat[$idx]} = 'sel' ]] && _stat[$idx]='none' || _stat[$idx]='del'
								go=1
								;;
							$PAGEUP)
								info="page up"
								;;
							$PAGEDOWN)
								info="page down"
								;;
						esac
					else
						printf "what?"
					fi
					;;
					$ESCAPE_SEQ)
						info="info:$ESCAPE_SEQ"
					;;
					"*"|"_"|".")
						case "$key" in
							"*") tmp="sel";;
							"_") tmp="del";;
							*)   tmp="none";;
						esac
						for i in ${!buf[@]}; do
							_stat[$i]="$tmp"
						done
						;;
					"+"|"=")
						_stat[$idx]='sel'
						;;
					"-")
						_stat[$idx]='del'
						;;
					"q")
						exitscreen
						exit 0;
						return 1
						;;
					"$SPACER")
						case "${_stat[$idx]}" in
							"sel") tmp="del";;
							"del") tmp="none";;
							"none")tmp="sel";;
							*);;
						esac
						_stat[$idx]=$tmp
						go=1
						;;
					"")
						go=1
						act=1
						;;
			esac

			clear

			if [ $act -eq 1 -a $go -eq 1 ]; then
				OUTPUT="${buf[$idx]}" #return value
				exitscreen
				return 0
			fi

		done

	}

	selection_sort(){
		local ret i stack keep skip buf len this this_st
		buf=($(get_buffer))
		len=$(buffer_size);
		if [ $len -gt 0 ]; then
			for i in ${!buf[@]}; do
				pre=
				this="${buf[$i]}"
				this_st="${_stat[$i]}"
				case "$this_st" in
					"sel")  keep+=("$this");;
					"del")  skip+=("$this");;
					"none") stack+=("$this");;
					*);;
				esac
			done
			OUTPUT="${keep[*]};${stack[*]};${skip[*]};${_stat[*]}"
			_buf=()
			_stat=()
		fi
	}

	filter_buffer(){
		local IFS this that match filt=() tmp=() ig=("${@}");
		IFS=$' '
		for this in ${_buf[@]}; do
			match=1
			for that in ${ig[@]}; do
				[[ "$this" =~ ^"$that".* ]] && match=0
			done
			[ $match -eq 1 ] && tmp+=( $this )  || :
			[ $match -eq 0 ] && filt+=( $this ) || :
		done
		echo "${tmp[@]}"
	}

#-------------------------------------------------------------------------------
# FIND
#-------------------------------------------------------------------------------

	find_repos(){
		local start="$1"
    _buf=($(find -H "$start" -mindepth 1 -name .git -type d ! -path . | sort ))
    printf "${_buf[*]}";
	}

#-------------------------------------------------------------------------------
# API
#-------------------------------------------------------------------------------

	relative_subpath(){
		local path=$1 clip=${2:-0};
		arr=(${path//\// });
		len=${#arr[@]}

		#clip array by n fields
		[ $clip -gt 0 ] && arr=("${arr[@]:0:((len-clip))}");
		this="$(joinby \/ ${arr[@]})";
		printf "$this";
	}


	select_groups(){

		local this j arr len rdir kg OIFS ret=1;

	  for this in ${_buf[@]}; do
	  	this=$(relative_subpath $this 1);
	  	name=$(basename $this);
	  	_named+=(${name//-/_})
	  	kg+=( $this )
	  done

	  #_buf=( $(printf "%s\n" "${kg[@]}" | uniq | sort ) );
	  uniq_buffer "${kg[@]}";

	  selection_buffer "Select Paths to add to Groups:"; ret=$?;
		[ $ret -eq 1 ] && return 1;

		selection_sort
	  clear_buffer;

		OIFS="$IFS"
		IFS=';' read -ra this <<< "$OUTPUT"
		kg=(${this[0]})
		ig=(${this[1]} ${this[2]})

		__group_list=(${this[0]})

		#for this in ${__group_list[@]}; do
		for j in ${!__group_list[@]}; do
			this=${__group_list[$j]};
			__gdir_map+=( "$BLADE_ROOT_SRC/$this" )
			__group_map+=($j)
		done

	}



	select_repos(){
		local this that kg filt=() keep=() ret OIFS;

		kg=(${__group_list[@]})

		for this in ${_buf[@]}; do
			this=$(relative_subpath $this);
			for that in ${kg[@]}; do
				[[ "$this" =~ ^(${that}).* ]] && keep+=($this) || filt+=($this);
			done
		done

		clear_buffer;
		uniq_buffer "${keep[@]}";

		selection_buffer "Select Projects to track:"; ret=$?
		[ $ret -eq 1 ] && return 1;

		selection_sort
		clear_buffer;

		OIFS="$IFS";
		IFS=';' read -ra this <<< "$OUTPUT";

		__proj_list=(${this[0]})
	}


	#TODO: refactor
	parse_buf(){
		local i j len this that IFS kg known_list name names=();

		buffer_load_repos;

		known_list=($(get_buffer));
		len=$(buffer_size);

		if [ $len -gt 0 ]; then

			select_groups;

			_buf=(${known_list[@]})
			len=${#_buf[@]}

			select_repos;

			kg=(${__proj_list[@]});

			for i in ${!kg[@]}; do

				this="${kg[$i]}"
				rthis="${_named[$i]}"
				nthis=${rthis//-/_}

				for j in ${!__group_list[@]}; do
					that="${__group_list[$j]}"
					case $this in
						$that/*)
							__alias_map+=($i)
							__alias_list+=($nthis)
							__repo_list+=($rthis)
							__rdir_map+=( "$BLADE_SRC/$this" )
						;;
						*) : ;;
					esac
				done
			done
			save_rc_file
		else
			log_warn "Len is $len"
		fi

	}


#-------------------------------------------------------------------------------
# SETUP
#-------------------------------------------------------------------------------
	ez_install(){
		log_silly "Ez Install NOOP"
	}


	auto_setup(){
		local path ret=1;

		ez_install;

		if confirm "Do you want to run Blade setup now (y/n)"; then

			if is_path "$BLADE_ROOT_SRC"; then
				path="$BLADE_ROOT_SRC";ret=0;
			else
				path=$(prompt_path "Where should Blade search for Repos ex: \$blue\$default\$x" "Search for repos in" "$HOME/src");ret=$?;
			fi

			(logo_screen && find_repos $path > "$BLADE_OUT" ) & wait_job "Searching for repos. This may take a minute" "Searched repos in ($path)"
			_git=($(cat $BLADE_OUT));
			sleep 2;
			clear_buffer;

			out="$path";

			[ $ret -eq 1 ] && return 1;

			BLADE_ROOT_SRC="$out"
			save_rc_file
			parse_buf

		else
		  err="Cancelled."
		fi

	}

#-------------------------------------------------------------------------------
# DISPATCH
#-------------------------------------------------------------------------------

	dispatch(){
		local call="$1" cmd run_cmd arg is_noop=$F ret;
		case "$call" in
			reset)
				rm "$BLADE_RC";
				rm "$BLADE_OUT";
			;;
			driver) : ;;
			ls)     : ;;
			go)     : ;;
			jump)   : ;;
			rc)     : ;;
			find)   : ;;
			setup)  : ;;
			each)
				case "$2" in
					stat) :
						_buf=("${__alias_list[@]}");
						print_buffer;
					;;
				esac
				;;
					*)  :
					;;
		esac
		log_warn 'hi you ran bladex'
	}

#-------------------------------------------------------------------------------
# MAIN
#-------------------------------------------------------------------------------


	main(){
		local ret;

		load_rc_file
		BLADE_ROOT_SRC="${opt_src_arg:-$BLADE_ROOT_SRC}"

		if ! is_true "$BLADE_LOAD"; then
			log_warn "Blade setup incomplete. Verifying..."
			sleep 0.5
			auto_setup; ret=$?;
		else
			# cd $BLADE_SRC
			dispatch "$@";ret=$?;
		fi

		[ -n "$err" ] && stderr "${red}$err" || stderr "$out";
		unset out err;
		return $ret
	}


	driver(){
		:
	}

#-------------------------------------------------------------------------------

  main "${args[@]}";

#-------------------------------------------------------------------------------
#=====================================!code=====================================








